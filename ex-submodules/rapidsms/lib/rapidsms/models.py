from __future__ import absolute_import
from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.utils.translation.trans_real import translation

from .errors import NoConnectionError, MessageSendingError
from .conf import settings


class Backend(models.Model):
    """
    This model isn't really a backend. Those are regular Python classes,
    in rapidsms/backends. This is just a stub model to provide a primary
    key for each running backend, so other models can be linked to it
    with ForeignKeys.
    """

    name = models.CharField(max_length=20, unique=True)

    def __unicode__(self):
        return self.name

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)


class App(models.Model):
    """
    This model isn't really a RapidSMS App. Like Backend, it's just a
    stub model to provide a primary key for each app, so other models
    can be linked to it.

    The Django ContentType stuff doesn't quite work here, since not all
    RapidSMS apps are valid Django apps. It would be nice to fill in the
    gaps and inherit from it at some point in the future.

    Instances of this model are generated by the update_apps management
    command, (which is hooked on Router startup (TODO: webui startup)),
    and probably shouldn't be messed with after that.
    """

    module = models.CharField(max_length=100, unique=True)
    active = models.BooleanField(default=False)

    def __unicode__(self):
        return self.module

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)


class ContactBase(models.Model):
    name = models.CharField(max_length=100, blank=True)

    # the spec: http://www.w3.org/International/articles/language-tags/Overview
    # reference:http://www.iana.org/assignments/language-subtag-registry
    language = models.CharField(max_length=6, blank=True, help_text=
        "The language which this contact prefers to communicate in, as "
        "a W3C language tag. If this field is left blank, RapidSMS will "
        "default to: " + settings.LANGUAGE_CODE)

    class Meta:
        abstract = True

    def __unicode__(self):
        return self.name or "Anonymous"

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)

    @property
    def is_anonymous(self):
        return not self.name

    @property
    def default_connection(self):
        """
        Return the default connection for this person.
        """
        # TODO: this is defined totally arbitrarily for a future 
        # sane implementation
        if self.connection_set.count() > 0:
            return self.connection_set.all()[0]
        return None

    def message(self, template, **kwargs):
        """
        Attempt to send a message to this contact via their default
        connection. Like any outgoing message, it may be aborted during
        the ``outgoing`` phase, or be rejected by the backend. In these
        cases, MessageSendingError is raised. If no default connection
        exists, NoConnectionError is raised.
        """

        if self.default_connection is None:
            raise NoConnectionError()

        was_sent = self.default_connection.message(
            template, **kwargs)

        if not was_sent:
            raise MessageSendingError()

        return True


class Contact(ContactBase):
    # if one person wants to submit stocks for multiple facilities, then
    # they'll have to create multiple contacts for themselves
    role = models.ForeignKey("logistics.ContactRole", null=True, blank=True)
    supply_point = models.ForeignKey("logistics.SupplyPoint", null=True, blank=True)
    needs_reminders = models.BooleanField(default=True)
    commodities = models.ManyToManyField("logistics.Product",
                                         help_text="User manages these commodities.",
                                         related_name="reported_by",
                                         blank=True)
    is_active = models.BooleanField(default=True)
    is_approved = models.BooleanField(default=False)
    organization = models.ForeignKey('malawi.Organization', null=True, blank=True)

    class Meta:
        verbose_name = "Logistics Contact"

    def __unicode__(self):
        if self.name:
            return self.name
        return unicode(self.pk)

    @property
    def phone(self):
        if self.default_connection:
            return self.default_connection.identity
        else:
            return " "

    @property
    def last_message(self):
        if self.message_set.count() > 0:
            return self.message_set.order_by("-date")[0]

    def commodities_reported(self):
        from logistics.models import Product
        """ this user is responsible for reporting these commodities """
        if settings.LOGISTICS_STOCKED_BY == settings.STOCKED_BY_USER:
            # do a join on all commodities associated with this user
            return Product.objects.filter(is_active=True).filter(reported_by=self)
        elif settings.LOGISTICS_STOCKED_BY == settings.STOCKED_BY_FACILITY:
            # look for products with active ProductStocks linked to user's facility
            return Product.objects.filter(productstock__supply_point=self.supply_point,
                                          productstock__is_active=True,
                                          is_active=True)
        elif settings.LOGISTICS_STOCKED_BY == settings.STOCKED_BY_PRODUCT:
            # all active Products in the system
            return Product.objects.filter(is_active=True)
        raise ImproperlyConfigured("LOGISTICS_STOCKED_BY setting is not configured correctly")

    @property
    def is_hsa(self):
        from logistics.models import ContactRole
        from logistics.util import config
        return self.role == ContactRole.objects.get(code=config.Roles.HSA)

    @property
    def associated_supply_point(self):
        """
        For HSA's return the parent facility. For everyone else return the
        exact supply point.
        """
        from logistics.models import SupplyPoint

        if not self.supply_point: return None

        if self.is_hsa:
            return SupplyPoint.objects.get(location=self.supply_point.location.parent)
        return self.supply_point

    @property
    def associated_supply_point_name(self):
        if self.associated_supply_point:
            return self.associated_supply_point.name
        else:
            return ""

    @property
    def hsa_id(self):
        if self.is_hsa:
            if self.supply_point:
                return self.supply_point.code
            else:
                return ""
        else:
            return ""

    def translate(self, message):
        """
        In newer versions of Django, this is accomplished using the
        django.utils.translation.override context manager.

        We could write our own context manager, but this process mirrors
        the one used in rapidsms.messages.outgoing.
        """
        language = self.language or settings.LANGUAGE_CODE
        return translation(language).gettext(message)

    @property
    def default_backend(self):
        # TODO: this is defined totally arbitrarily for a future
        # sane implementation
        if settings.DEFAULT_BACKEND:
            return Backend.objects.get(name=settings.DEFAULT_BACKEND)
        else:
            return Backend.objects.all()[0]

    @property
    def default_connection(self):
        """
        Return the default connection for this person.
        """
        # TODO: this is defined totally arbitrarily for a future
        # sane implementation
        if self.connection_set.count() > 0:
            return self.connection_set.all()[0]
        return None

    @default_connection.setter
    def default_connection(self, identity):
        backend = self.default_backend
        default = self.default_connection
        if default is not None:
            if default.identity == identity and default.backend == backend:
                # our job is done
                return
            # when you re-assign default connection,
            # should you delete the unused connection?
            # probably not because who knows what else will get deleted in the
            # cascade
            # default.delete()
        try:
            conn = Connection.objects.get(backend=backend, identity=identity)
        except Connection.DoesNotExist:
            # good, it doesn't exist already
            conn = Connection(backend=backend,
                              identity=identity)
        conn.contact = self
        conn.save()


class Connection(models.Model):
    """
    This model pairs a Backend object with an identity unique to it (eg.
    a phone number, email address, or IRC nick), so RapidSMS developers
    need not worry about which backend a messge originated from.
    """

    backend  = models.ForeignKey(Backend)
    identity = models.CharField(max_length=100)
    contact  = models.ForeignKey(Contact, null=True, blank=True)

    class Meta:
        unique_together = (('backend', 'identity'),)

    def __unicode__(self):
        return "%s via %s" %\
            (self.identity, self.backend)

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)

    def message(self, template, **kwargs):
        """
        Attempt to send a message to this connection. Like any outgoing
        message, it may be aborted during the ``outgoing`` phase, or be
        rejected by the backend. In these cases, MessageSendingError is
        raised. (There is currently no way to know *why* the message was
        not sent, so we raise a generic error.)

        This method can only be called in the ``runrouter`` process,
        since the router is currently not accessible from the webui
        process(es). If no router is running, NoRouterError is raised
        (by the ``OutgoingMessage.send`` method).
        """

        from .messages.outgoing import OutgoingMessage
        was_sent = OutgoingMessage(self, template, **kwargs).send()

        if not was_sent:
            raise MessageSendingError()

        return True


class DeliveryReport(models.Model):
    '''
    This model is used for delivery reports from sending SMS messages
    using a gateway.
    '''
    action = models.CharField(max_length=255)
    report_id = models.CharField(max_length=255, help_text='Gateway assigned ID')
    number = models.CharField(max_length=255, help_text='Destination telephone number')
    report = models.CharField(max_length=255, help_text='Actual report text')
