{% extends "messaging/base.html" %}
{% block title %}Messaging{% endblock %}
{% load reporters %}

{% block javascripts %}
<script type="text/javascript" src="/static/webui/javascripts/jquery.cookie.yc.js"></script>
{% endblock %}

{% block content %}
<div class="split">
	<div class="left">
		<div class="module recipients">
			<h2>Select Recipients</h2>
			<div class="search">
				<select name="column">
					<option value="">Any Column</option>{% for name, title in columns %}
					<option value="{{ name }}">{{ title }}</option>{% endfor %}
				</select>
				
				<select name="operation">
					<option value="icontains">contains</option>
					<option value="iexact">equals</option>
					<option value="istartswith">starts with</option>
					<option value="iendswith">ends with</option>
					<option value="lt">is less than</option>
					<option value="gt">is more than</option>
				</select>
				
				<input type="text" name="search" value="" size="14" />
			</div>
			<table>
				<thead>
					<tr>
						<th></th>
						<th>Name</th>
						<th>Role</th>
						<th>Location</th>
					</tr>
				</thead>
				<tbody>{% for reporter in reporters.object_list %}
					<tr uid="{{ reporter.pk }}">
						<td class="check"></td>
						<td>{{ reporter.full_name }}</td>
						<td>{{ reporter.role }}</td>
						<td>{{ reporter.location }}</td>
					</tr>{% endfor %}
				</tbody>
				<tfoot>
					<tr>
						<td colspan="4">
							<div class="paginator">{% if reporters.has_previous %}
								<a href="{% self_link "page" 1 %}" class="first" title="First page">First Page</a>
								<a href="{% self_link "page" reporters.previous_page_number %}" class="prev" title="Previous page">Previous Page</a>{% else %}
								<span class="first na" title="You are already on the first page">First Page</span>
								<span class="prev na" title="There are no previous pages">Previous Page</span>{% endif %}{% for page in reporters.paginator.page_range %}
								<a href="{% self_link "page" page %}"{% ifequal page reporters.number %} class="active"{% endifequal %} title="Page {{ page }}">{{ page }}</a>{% endfor %}{% if reporters.has_next %}
								<a href="{% self_link "page" reporters.next_page_number %}" class="next" title="Next page">Next Page</a>
								<a href="{% self_link "page" reporters.paginator.num_pages %}" class="last" title="Last page">Last Page</a>{% else %}
								<span class="next na" title="There are no more pages">Next Page</span>
								<span class="last na" title="You are already on the last page">Last Page</span>{% endif %}
							</div>
							
							<a href="/messaging/none" class="none" title="Select No Recipients">None</a>
							<a href="/messaging/all" class="all" title="Select All Recipients">All</a>
							<a href="/messaging/clear" class="clear" title="Clear Message Statuses">Clear</a>
						</td>
					</tr>
				</tfoot>
			</table>
    </div>
	</div>
	<div class="right">
		<div class="module contents">
			<h2>Message Contents</h2>
			<textarea cols="40" rows="6"></textarea>
			<input type="button" class="send" value="Send Messages" />
			<input type="button" class="cancel" value="Cancel" disabled="disabled" />
		</div>
	</div>
	<div class="clear-hack"></div>
</div>

<script type="text/javascript">
	$(function() {
		var search_div  = $("div.module.recipients div.search");
		var recip_div   = $("div.module.recipients");
		var content_div = $("div.module.contents");
	
		var msg_txta   = $("textarea",     content_div);
		var send_btn   = $("input.send",   content_div);
		var cancel_btn = $("input.cancel", content_div);
		
		var recip_rows = $("tbody tr",      recip_div);
		var clear_link = $("tfoot a.clear", recip_div);
		var all_link   = $("tfoot a.all",   recip_div);
		var none_link  = $("tfoot a.none",  recip_div);
		
		
		/* these tooltips are attached to the status icon of
		 * each row, when we have something unimportant to say */
		var ICON_TOOLTIPS = {
			"error": "Error: Message Not Sent",
			"sent":  "OK: Message Sent"
		};
		
		var sending = false;
		var send_xhr = null;
		
		
		
		
		/* ======= *
		 * HELPERS *
		 * ======= */
		
		
		/* returns an array containing the UID of every recipient
		 * that is currently cookied with the specified status
		 * (checked, error, or sent). this is not as simple as it
		 * should be, because Array.split returns [""] for empty
		 * strings (?!), and we must forgive superfluous spaces */
		var cookie_recips = function(status) {
			var flat_recips = $.trim($.cookie("recip-" + status));
			return flat_recips ? flat_recips.split(/\s+/) : [];
		};
		
		
		/* removes all recipients of the specified status. there
		 * is no equivalent "select all", because we don't know
		 * all of the possible UIDs */
		var clear_cookie_recips = function(status) {
			$.cookie("recip-" + status, null);
		};
		
		
		/* iterate the recipients of the specified status, and re-
		 * write the cookie after adding (value=true) or removing
		 * (value=false) the reporter of UID */
		var set_cookie_recip = function(uid, status, value) {
			var recips = cookie_recips(status);
			
			if(value) {
				if($.inArray(uid, recips) == -1)
					recips.push(uid);
			
			} else {
				recips = $.grep(recips, function(recip_uid) {
					return recip_uid != uid;
				});
			}
			
			/* rebuild the flat cookie string from the array. if nothing
			 * is are going to be stored, delete the cookie (=null) */
			var flat_recips = recips.join(" ");
			if(flat_recips == "") flat_recips = null;
			$.cookie("recip-" + status, flat_recips);
			
			/* update the dom */
			//update_row(uid);
		};
		
		
		/* returns the <tr> containing a recipient identified
		 * by their UID, or an empty array if none was found.
		 * NOTE: the UID could still be valid on another page! */
		var row_via_uid = function(uid) {
			return $("tbody tr[uid=" + uid + "]", recip_div);
		};
		
		
		/* updates the class names of the reporter's row (by providing
		 * either a jQuery object or a UID to fetch), by checking
		 * for the UID in the various "recip-%s" cookies */
		var update_row = function(row_or_uid) {
			var row = (typeof(row_or_uid) == "object")
			        ? $(row_or_uid) : row_via_uid(row_or_uid);
			
			$.each(["checked", "error", "sent", "hit"], function(n, status) {
				var in_arr = $.inArray(row.attr("uid"), cookie_recips(status));
				(in_arr == -1) ? row.removeClass(status) : row.addClass(status);
			});
			
			/* update this row's icon's tooltip, depending on
			 * the css classes it now has, via a "constant" */
			$("td.check", row).attr("title", ICON_TOOLTIPS[row.attr("class")] || "");
		};
		
		
		/* calls update_row for each row (note: this
		 * DOES NOT cover recipients on other pages) */
		var update_all_rows = function() {
			recip_rows.each(function() {
				update_row(this);
			});
		};
		
		
		/* updates N in the caption of the "send N messages"
		 * button, and disable it if we're not ready to send. */
		var update_buttons = function() {
			var n = cookie_recips("checked").length;
			var suffix = (n == 1) ? "" : "s";
			
			/* if we're currently busy sending messages, then
			 * prevent the button from being clicked again */
			if(send_xhr != null) {
				var capt = "Sending " + n + " Message" + suffix + "...";
				send_btn.attr("value", capt).attr("disabled", true);

			/* disable the button unless some recipients are
			 * selected, and some text has been entered */
			} else {
				var capt = "Send " + n + " Message" + suffix;
				var invalid = (n == 0 || msg_txta.attr("value") == "");
				send_btn.attr("value", capt).attr("disabled", invalid);
			}
			
			/* the cancel button is only ever enabled
			 * while we're busy sending messages */
			cancel_btn.attr("disabled", (send_xhr == null));
		};
		
		
		
		
		/* ====== *
		 * EVENTS *
		 * ====== */
		
		
		/* when the "checked" class of the row is clicked (each <tr> displays
		 * a single recipient, and add (or remove) the recipient's UID from
		 * the cookie, to instruct views.py to pre-check this recipient the
		 * next time we view them, in whatever context */
		$("td.check", recip_rows).click(function(ev) {
			var row = $(ev.target).parent("tr");
			var uid = row.attr("uid");
			
			/* clear any ERROR or SENT statuses. the button
			 * is small, and a click is a good enough indication
			 * that the visitor has seen and understood the icon */
			if(row.hasClass("error") || row.hasClass("sent")) {
				set_cookie_recip(uid, "error", false);
				set_cookie_recip(uid, "sent", false);
				
			/* toggle the "checked" cookie, which will
			 * update the class in update_row */
			} else set_cookie_recip(uid, "checked", !row.hasClass("checked"));
			
			/* update the dom */
			update_row(uid);
			update_buttons();
		});
		
		
		(function() {
			var timeout = null;
			var last_val = null;
			
			$("input[name=search]", search_div).bind("keypress change", function(ev) {
				if(timeout) clearTimeout(timeout);
				timeout = setTimeout(function() {
					var val = $(ev.target).val();
					var filters = {};
				
					/* don't search again if nothing
					 * has changed since the last */
					if(last_val == val) return false;
					last_val = val;
					
					/* build a query string using the Column and
					 * Operation <selects> to create django filters */
					var col = $("select[name=column]", search_div);
					var op  = $("select[name=operation]", search_div);
					var key = col.val() + "__" + op.val();
					filters[key] = val;
					
					$.get("{% url messaging-search %}", filters, function(data) {
						$("tbody", recip_div).addClass("filtered");
						$.cookie("recip-hit", data);
						update_all_rows();
					});
				}, 1000);
			});
		})();
		
		
		/* TODO */
		send_btn.click(function() {
			var text = msg_txta.attr("value");
			
			/* clear any status icons left lingering
			 * around by the previous message blast */
			clear_link.click();
			
			/* starts the next pending ajax request,
			 * to send a single message, or resets
			 * the buttons if none are left */
			var next = function() {
				
				/* if we're done, update the buttons
				 * to allow the next blast to be sent */
				if(!queue.length) {
					send_xhr = null;
					update_buttons();
				
				/* we're not done yet, so call the next 
				 * queued function to start the ajax */
				} else {
					send_xhr = true;
					update_buttons();
					return queue.shift()();
				}
			};
			
			/* create an array of closures, which we
			 * will call later in serial, to POST each
			 * message back to messaging/app.py */
			var queue = $.map(cookie_recips("checked"), function(uid) {
				var row = row_via_uid(uid);
				
				var done = function(klass) {
					set_cookie_recip(uid, "checked", false);
					set_cookie_recip(uid, klass, true);
					row.removeClass("busy");
					update_row(row);
					next();
				};
				
				return(function() {
					row.addClass("busy");
					
					send_xhr = $.ajax({
						"type": "POST",
						"url":  "/ajax/messaging/send_message",
						"data": {
							"uid":  uid,
							"text": text,
						},
						"success": function()    { done("sent"); },
						"error":   function(xhr) { done("error"); }
					});
				});
			});
			
			/* start sending */
			next();
		});
		
		
		/* when cancel is clicked, terminate the current
		 * xhr request (if one is pending), and reset the
		 * buttons to allow a revised message to be sent */
		cancel_btn.click(function() {
			if(send_xhr)
				send_xhr.abort();
			send_xhr = null;
			update_buttons();
		});
		
		
		/* clears the statuses of all recipients (by
		 * destroying the cookies) and update each row
		 * of recipients (to remov the icon) */
		clear_link.click(function(ev) {
			ev.preventDefault();
			
			recip_rows.removeClass("busy");
			$.cookie("recip-error", null);
			$.cookie("recip-sent", null);
			update_all_rows();
		});
		
		
		/* fetches a list of all uids from the server, which is
		 * (conveniently) in the right format to jam straight into
		 * the recip-checked cookie, to select ALL recipients. note
		 * that we use a ghetto cache here, since the fetch can take
		 * a few seconds on a slow connection */
		(function() {
			var ajax_cache = "";
			
			var apply = function() {
				$.cookie("recip-checked", ajax_cache);
				update_all_rows();
			};
			
			all_link.click(function(ev) {
				ev.preventDefault();
				
				/* if we've already fetched the uids,
				 * copy them into the cookie immediately */
				if(ajax_cache) {
					apply();
				
				/* otherwise; fetch them via ajax,
				 * cache them, and copy the cookie */
				} else {
					$.get(ev.target.href, function(data) {
						ajax_cache = data;
						apply();
					});
				}
			});
		})();
		
		
		/* scraps the recip-checked cookie, to select
		 * NO recipients without reloading the page */
		none_link.click(function(ev) {
			ev.preventDefault();
			
			$.cookie("recip-checked", null);
			update_all_rows();
		});
		
		
		/* every time the message field is changed (by
		 * typing *OR* otherwise (cut, paste, etc), set
		 * a timeout to upate the send button AFTER the
		 * event has propagated. this is a hack. */
		msg_txta.bind("keypress change", function() {
			setTimeout(update_buttons, 20);
		});
		
		
		
		
		/* ============== *
		 * INITIALIZATION *
		 * ============== */

		/* expand the search box to fill the remaining space
		 * to the right. this is pointless but rather pretty */
		$(".search input[name=search]", recip_div).each(function() {
			var input = $(this);
		
			var box_offset = $(input.parent().children()[0]).offset()["left"];
			var inp_offset = input.offset()["left"] - box_offset;
			var inp_width  = input.parent().width() - inp_offset;
			
			input.css({
				"-moz-box-sizing": "border-box",
				"width": inp_width
			});
		});
		
		
		/* update the dom now, to select cookied
			* recipients and update the buttons */
		update_all_rows();
		update_buttons();
	});
</script>
{% endblock %}
